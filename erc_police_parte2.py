#!/usr/bin/env python3
"""
üè• ERC POLICE WATCHDOG - PARTE 2: FUNCIONES DE CHEQUEO Y ENFORCEMENT M√âDICO
===========================================================================

Implementa todas las funciones de monitoreo m√©dico, enforcement de reglas
cl√≠nicas y validaciones espec√≠ficas para la aplicaci√≥n ERC Insight.

CONECTA CON PARTE 1: Usa decoradores, config y logging de erc_police_parte1.py
PREPARA PARA PARTE 3: Genera eventos para manejo de errores y alertas
"""

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# IMPORTS DESDE PARTE 1 Y EXTENSIONES
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

import os
import sys
import json
import time
import sqlite3
import requests
import threading
from pathlib import Path
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any, Union, Tuple
from dataclasses import dataclass
import hashlib
import re

# Importar desde PARTE 1 (asegurar que est√© en el path)
sys.path.append(os.path.dirname(os.path.abspath(__file__)))

# Simular importaci√≥n de PARTE 1 (en implementaci√≥n real ser√≠a: from erc_police_parte1 import *)
try:
    from erc_police_parte1 import (
        ERCPoliceWatchdog, POLICE_CONFIG, POLICE_LOGGER, 
        police_monitor, medical_validation, ERCPoliceConfig
    )
    PARTE1_AVAILABLE = True
except ImportError:
    # Fallback si PARTE 1 no est√° disponible
    PARTE1_AVAILABLE = False
    print("‚ö†Ô∏è PARTE 1 no disponible - usando configuraci√≥n b√°sica")
    
    # Configuraci√≥n m√≠nima para funcionar standalone
    class POLICE_LOGGER:
        @staticmethod
        def info(msg): print(f"INFO: {msg}")
        @staticmethod 
        def warning(msg): print(f"WARNING: {msg}")
        @staticmethod
        def error(msg): print(f"ERROR: {msg}")
    
    def police_monitor(name):
        def decorator(func):
            def wrapper(*args, **kwargs):
                return func(*args, **kwargs)
            return wrapper
        return decorator
    
    def medical_validation(name):
        def decorator(func):
            def wrapper(*args, **kwargs):
                return func(*args, **kwargs)
            return wrapper
        return decorator

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# VALIDADORES M√âDICOS ESPEC√çFICOS DE ERC
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ERCMedicalValidator:
    """Validador especializado en reglas m√©dicas de ERC Insight"""
    
    def __init__(self, config = None):
        self.config = config if config else self._get_default_medical_config()
        self.validation_log = []
        self.lock = threading.Lock()
    
    def _get_default_medical_config(self):
        """Configuraci√≥n m√©dica por defecto"""
        return {
            "tfg_ranges": {
                "g1": {"min": 90, "max": float('inf')},
                "g2": {"min": 60, "max": 89},
                "g3a": {"min": 45, "max": 59},
                "g3b": {"min": 30, "max": 44},
                "g4": {"min": 15, "max": 29},
                "g5": {"min": 0, "max": 14}
            },
            "therapeutic_goals": {
                "presion_arterial": {"max_sistolica": 140, "max_diastolica": 90},
                "glicemia": {"max_value": 130},
                "colesterol_ldl": {"max_value": 100},
                "rac": {"max_value": 30}
            },
            "medication_rules": {
                "ieca_ara2_contraindications": ["potasio_alto", "tfg_menor_30"],
                "metformina_restrictions": ["tfg_menor_30"],
                "isglt2_restrictions": ["tfg_menor_30"]
            }
        }
    
    @medical_validation("cockcroft_gault_calculation")
    def validate_tfg_cockcroft_gault(self, edad: int, peso: float, creatinina: float, sexo: str) -> Dict[str, Any]:
        """
        Valida y calcula TFG usando f√≥rmula Cockcroft-Gault con enforcement estricto
        """
        validation_result = {
            "timestamp": datetime.now().isoformat(),
            "function": "validate_tfg_cockcroft_gault",
            "input": {"edad": edad, "peso": peso, "creatinina": creatinina, "sexo": sexo},
            "status": "pending",
            "tfg": None,
            "estadio": None,
            "alerts": [],
            "errors": []
        }
        
        try:
            # üö® ENFORCEMENT: Validaci√≥n de par√°metros de entrada
            if not isinstance(edad, int) or edad <= 0 or edad > 120:
                validation_result["errors"].append(f"Edad inv√°lida: {edad}. Debe ser entero entre 1-120")
            
            if not isinstance(peso, (int, float)) or peso <= 0 or peso > 300:
                validation_result["errors"].append(f"Peso inv√°lido: {peso}. Debe ser entre 1-300 kg")
            
            if not isinstance(creatinina, (int, float)) or creatinina <= 0 or creatinina > 20:
                validation_result["errors"].append(f"Creatinina inv√°lida: {creatinina}. Debe ser entre 0.1-20 mg/dL")
            
            if sexo.lower() not in ['m', 'f', 'masculino', 'femenino']:
                validation_result["errors"].append(f"Sexo inv√°lido: {sexo}. Debe ser 'm', 'f', 'masculino' o 'femenino'")
            
            if validation_result["errors"]:
                validation_result["status"] = "error"
                return validation_result
            
            # üßÆ C√ÅLCULO DE TFG - F√≥rmula Cockcroft-Gault
            factor_sexo = 0.85 if sexo.lower() in ['f', 'femenino'] else 1.0
            tfg = ((140 - edad) * peso * factor_sexo) / (72 * creatinina)
            tfg = round(tfg, 2)
            
            # üö® ENFORCEMENT: Validaci√≥n de resultado
            if tfg < 0 or tfg > 200:
                validation_result["errors"].append(f"TFG calculado fuera de rango v√°lido: {tfg}")
                validation_result["status"] = "error"
                return validation_result
            
            # üè• CLASIFICACI√ìN POR ESTADIOS KDIGO
            estadio = self._classify_erc_stage(tfg)
            
            # üö® ALERTAS M√âDICAS CR√çTICAS
            if tfg < 15:  # Estadio G5
                validation_result["alerts"].append("CR√çTICO: TFG < 15 - Considerar terapia de reemplazo renal")
            elif tfg < 30:  # Estadio G4
                validation_result["alerts"].append("ALERTA: TFG < 30 - Preparar para terapia renal, referir nefrolog√≠a")
            elif tfg < 45:  # Estadio G3b
                validation_result["alerts"].append("PRECAUCI√ìN: TFG < 45 - Monitoreo intensivo, ajustar medicamentos")
            
            # ‚úÖ RESULTADO EXITOSO
            validation_result.update({
                "status": "success",
                "tfg": tfg,
                "estadio": estadio,
                "formula_used": "Cockcroft-Gault",
                "interpretation": self._get_tfg_interpretation(tfg, estadio)
            })
            
            # üìä LOG DE VALIDACI√ìN
            self._log_medical_validation(validation_result)
            
            return validation_result
            
        except Exception as e:
            validation_result["status"] = "error"
            validation_result["errors"].append(f"Error en c√°lculo: {str(e)}")
            POLICE_LOGGER.error(f"üö® Error en validaci√≥n TFG: {str(e)}")
            return validation_result
    
    def _classify_erc_stage(self, tfg: float) -> str:
        """Clasifica estadio ERC seg√∫n TFG"""
        for stage, range_data in self.config["tfg_ranges"].items():
            if range_data["min"] <= tfg <= range_data["max"]:
                return stage
        return "unknown"
    
    def _get_tfg_interpretation(self, tfg: float, estadio: str) -> str:
        """Genera interpretaci√≥n cl√≠nica del TFG"""
        interpretations = {
            "g1": f"Normal o aumentado (TFG: {tfg}). Funci√≥n renal normal si no hay da√±o renal.",
            "g2": f"Ligeramente disminuido (TFG: {tfg}). Funci√≥n renal normal si no hay da√±o renal.",
            "g3a": f"Moderadamente disminuido (TFG: {tfg}). ERC estadio 3a - monitoreo regular.",
            "g3b": f"Moderadamente a severamente disminuido (TFG: {tfg}). ERC estadio 3b - seguimiento nefrol√≥gico.",
            "g4": f"Severamente disminuido (TFG: {tfg}). ERC estadio 4 - preparar terapia de reemplazo renal.",
            "g5": f"Falla renal (TFG: {tfg}). ERC estadio 5 - terapia de reemplazo renal necesaria."
        }
        return interpretations.get(estadio, f"TFG: {tfg} - Clasificaci√≥n no determinada")
    
    @medical_validation("cardiovascular_risk_assessment")
    def validate_cardiovascular_risk(self, patient_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Valida y calcula riesgo cardiovascular con enforcement de reglas m√©dicas
        """
        validation_result = {
            "timestamp": datetime.now().isoformat(),
            "function": "validate_cardiovascular_risk",
            "input": patient_data,
            "status": "pending",
            "risk_level": None,
            "score": 0,
            "factors": [],
            "alerts": [],
            "errors": []
        }
        
        try:
            required_fields = ["edad", "sexo", "tfg"]
            missing_fields = [field for field in required_fields if field not in patient_data]
            
            if missing_fields:
                validation_result["errors"].append(f"Campos obligatorios faltantes: {missing_fields}")
                validation_result["status"] = "error"
                return validation_result
            
            # üßÆ C√ÅLCULO DE RIESGO CARDIOVASCULAR
            risk_score = 0
            risk_factors = []
            
            # Factor edad
            edad = patient_data["edad"]
            if edad >= 75:
                risk_score += 3
                risk_factors.append(f"Edad ‚â•75 a√±os ({edad})")
            elif edad >= 65:
                risk_score += 2
                risk_factors.append(f"Edad ‚â•65 a√±os ({edad})")
            
            # Factor TFG/ERC
            tfg = patient_data.get("tfg", 0)
            if tfg < 30:
                risk_score += 4
                risk_factors.append(f"ERC estadio G4-G5 (TFG: {tfg})")
            elif tfg < 60:
                risk_score += 2
                risk_factors.append(f"ERC estadio G3 (TFG: {tfg})")
            
            # Factores de comorbilidad
            if patient_data.get("dm2", False):
                risk_score += 3
                risk_factors.append("Diabetes mellitus tipo 2")
            
            if patient_data.get("hta", False):
                risk_score += 2
                risk_factors.append("Hipertensi√≥n arterial")
            
            if patient_data.get("dislipidemia", False):
                risk_score += 1
                risk_factors.append("Dislipidemia")
            
            if patient_data.get("tabaquismo", False):
                risk_score += 2
                risk_factors.append("Tabaquismo activo")
            
            if patient_data.get("antecedente_cv", False):
                risk_score += 4
                risk_factors.append("Antecedente cardiovascular")
            
            # üè• CLASIFICACI√ìN DE RIESGO
            if risk_score >= 8:
                risk_level = "muy_alto"
            elif risk_score >= 5:
                risk_level = "alto"
            elif risk_score >= 2:
                risk_level = "moderado"
            else:
                risk_level = "bajo"
            
            # üö® ALERTAS M√âDICAS ESPEC√çFICAS
            if risk_level == "muy_alto":
                validation_result["alerts"].append("RIESGO MUY ALTO: Requiere intervenci√≥n intensiva y seguimiento estrecho")
            elif risk_level == "alto":
                validation_result["alerts"].append("RIESGO ALTO: Requiere control estricto de factores de riesgo")
            
            validation_result.update({
                "status": "success",
                "risk_level": risk_level,
                "score": risk_score,
                "factors": risk_factors,
                "interpretation": self._get_cv_risk_interpretation(risk_level, risk_score)
            })
            
            self._log_medical_validation(validation_result)
            return validation_result
            
        except Exception as e:
            validation_result["status"] = "error"
            validation_result["errors"].append(f"Error en evaluaci√≥n de riesgo: {str(e)}")
            return validation_result
    
    def _get_cv_risk_interpretation(self, risk_level: str, score: int) -> str:
        """Genera interpretaci√≥n del riesgo cardiovascular"""
        interpretations = {
            "bajo": f"Riesgo cardiovascular bajo (Score: {score}). Manejo conservador con estilo de vida.",
            "moderado": f"Riesgo cardiovascular moderado (Score: {score}). Control de factores de riesgo.",
            "alto": f"Riesgo cardiovascular alto (Score: {score}). Tratamiento farmacol√≥gico y seguimiento.",
            "muy_alto": f"Riesgo cardiovascular muy alto (Score: {score}). Intervenci√≥n intensiva inmediata."
        }
        return interpretations.get(risk_level, f"Riesgo no determinado (Score: {score})")
    
    @medical_validation("therapeutic_goals_compliance")
    def validate_therapeutic_goals(self, patient_data: Dict[str, Any], lab_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Valida cumplimiento de metas terap√©uticas seg√∫n perfil del paciente
        """
        validation_result = {
            "timestamp": datetime.now().isoformat(),
            "function": "validate_therapeutic_goals",
            "input": {"patient": patient_data, "labs": lab_data},
            "status": "pending",
            "goals_met": [],
            "goals_not_met": [],
            "compliance_score": 0,
            "alerts": [],
            "errors": []
        }
        
        try:
            # üè• DEFINIR METAS SEG√öN PERFIL DEL PACIENTE
            tfg = patient_data.get("tfg", 0)
            tiene_dm = patient_data.get("dm2", False)
            
            # Metas de presi√≥n arterial
            if "presion_sistolica" in lab_data and "presion_diastolica" in lab_data:
                sistolica = lab_data["presion_sistolica"]
                diastolica = lab_data["presion_diastolica"]
                
                # Meta m√°s estricta para pacientes con ERC + DM
                meta_sistolica = 130 if (tiene_dm or tfg < 60) else 140
                meta_diastolica = 80 if (tiene_dm or tfg < 60) else 90
                
                if sistolica <= meta_sistolica and diastolica <= meta_diastolica:
                    validation_result["goals_met"].append({
                        "parameter": "presion_arterial",
                        "value": f"{sistolica}/{diastolica}",
                        "goal": f"‚â§{meta_sistolica}/{meta_diastolica}",
                        "status": "achieved"
                    })
                else:
                    validation_result["goals_not_met"].append({
                        "parameter": "presion_arterial", 
                        "value": f"{sistolica}/{diastolica}",
                        "goal": f"‚â§{meta_sistolica}/{meta_diastolica}",
                        "status": "not_achieved"
                    })
                    if sistolica > 160 or diastolica > 100:
                        validation_result["alerts"].append("CR√çTICO: Hipertensi√≥n severa - Ajuste inmediato de tratamiento")
            
            # Metas de glicemia (si diabetes)
            if tiene_dm and "glicemia" in lab_data:
                glicemia = lab_data["glicemia"]
                meta_glicemia = 130
                
                if glicemia <= meta_glicemia:
                    validation_result["goals_met"].append({
                        "parameter": "glicemia",
                        "value": glicemia,
                        "goal": f"‚â§{meta_glicemia} mg/dL",
                        "status": "achieved"
                    })
                else:
                    validation_result["goals_not_met"].append({
                        "parameter": "glicemia",
                        "value": glicemia,
                        "goal": f"‚â§{meta_glicemia} mg/dL", 
                        "status": "not_achieved"
                    })
                    if glicemia > 200:
                        validation_result["alerts"].append("CR√çTICO: Hiperglicemia severa - Control inmediato")
            
            # Meta de RAC (Relaci√≥n Alb√∫mina-Creatinina)
            if "rac" in lab_data:
                rac = lab_data["rac"]
                meta_rac = 30
                
                if rac <= meta_rac:
                    validation_result["goals_met"].append({
                        "parameter": "rac",
                        "value": rac,
                        "goal": f"‚â§{meta_rac} mg/g",
                        "status": "achieved"
                    })
                else:
                    validation_result["goals_not_met"].append({
                        "parameter": "rac",
                        "value": rac,
                        "goal": f"‚â§{meta_rac} mg/g",
                        "status": "not_achieved"
                    })
                    if rac > 300:
                        validation_result["alerts"].append("CR√çTICO: Macroalbuminuria - Protecci√≥n renal urgente")
            
            # üìä CALCULAR SCORE DE CUMPLIMIENTO
            total_goals = len(validation_result["goals_met"]) + len(validation_result["goals_not_met"])
            if total_goals > 0:
                compliance_score = (len(validation_result["goals_met"]) / total_goals) * 100
                validation_result["compliance_score"] = round(compliance_score, 1)
            
            validation_result["status"] = "success"
            self._log_medical_validation(validation_result)
            return validation_result
            
        except Exception as e:
            validation_result["status"] = "error"
            validation_result["errors"].append(f"Error en validaci√≥n de metas: {str(e)}")
            return validation_result
    
    @medical_validation("medication_safety_check")
    def validate_medication_safety(self, patient_data: Dict[str, Any], medications: List[str]) -> Dict[str, Any]:
        """
        Valida seguridad de medicamentos seg√∫n estado del paciente
        """
        validation_result = {
            "timestamp": datetime.now().isoformat(),
            "function": "validate_medication_safety",
            "input": {"patient": patient_data, "medications": medications},
            "status": "pending",
            "safe_medications": [],
            "contraindicated_medications": [],
            "dose_adjustments": [],
            "alerts": [],
            "errors": []
        }
        
        try:
            tfg = patient_data.get("tfg", 0)
            potasio = patient_data.get("potasio", 0)
            
            for medication in medications:
                med_lower = medication.lower()
                
                # üö® CONTRAINDICACIONES POR TFG
                if tfg < 30:
                    if any(med in med_lower for med in ["metformina", "metformin"]):
                        validation_result["contraindicated_medications"].append({
                            "medication": medication,
                            "reason": f"TFG < 30 ml/min ({tfg}) - Riesgo de acidosis l√°ctica",
                            "severity": "critical"
                        })
                        validation_result["alerts"].append(f"CR√çTICO: Suspender {medication} - TFG < 30")
                        continue
                    
                    if any(med in med_lower for med in ["empagliflozina", "dapagliflozina", "canagliflozina"]):
                        validation_result["contraindicated_medications"].append({
                            "medication": medication,
                            "reason": f"TFG < 30 ml/min ({tfg}) - Efectividad reducida",
                            "severity": "moderate"
                        })
                        continue
                
                # üîÑ AJUSTES DE DOSIS
                if 15 <= tfg <= 45:
                    if any(med in med_lower for med in ["enalapril", "lisinopril", "losartan", "valsartan"]):
                        validation_result["dose_adjustments"].append({
                            "medication": medication,
                            "adjustment": "Reducir dosis 25-50% y monitorizar K+ y creatinina c/1-2 semanas",
                            "reason": f"TFG moderadamente reducido ({tfg})"
                        })
                
                # ‚ö†Ô∏è MONITOREO ESPECIAL
                if potasio > 5.5:
                    if any(med in med_lower for med in ["enalapril", "lisinopril", "losartan", "valsartan", "espironolactona"]):
                        validation_result["alerts"].append(f"PRECAUCI√ìN: {medication} con K+ elevado ({potasio}) - Monitoreo estrecho")
                
                # ‚úÖ MEDICAMENTO SEGURO
                if medication not in [item["medication"] for item in validation_result["contraindicated_medications"]]:
                    validation_result["safe_medications"].append({
                        "medication": medication,
                        "status": "safe",
                        "notes": "Sin contraindicaciones detectadas"
                    })
            
            validation_result["status"] = "success"
            self._log_medical_validation(validation_result)
            return validation_result
            
        except Exception as e:
            validation_result["status"] = "error" 
            validation_result["errors"].append(f"Error en validaci√≥n de medicamentos: {str(e)}")
            return validation_result
    
    def _log_medical_validation(self, validation_result: Dict[str, Any]):
        """Registra validaci√≥n m√©dica en log"""
        with self.lock:
            self.validation_log.append(validation_result)
            
            # Mantener solo las √∫ltimas 1000 validaciones
            if len(self.validation_log) > 1000:
                self.validation_log = self.validation_log[-1000:]
    
    def get_validation_summary(self) -> Dict[str, Any]:
        """Obtiene resumen de validaciones realizadas"""
        with self.lock:
            total = len(self.validation_log)
            if total == 0:
                return {"total": 0, "success": 0, "errors": 0, "success_rate": 0}
            
            success = sum(1 for v in self.validation_log if v["status"] == "success")
            errors = total - success
            
            return {
                "total_validations": total,
                "successful": success,
                "errors": errors,
                "success_rate": round((success / total) * 100, 1),
                "last_24h": len([v for v in self.validation_log 
                               if (datetime.now() - datetime.fromisoformat(v["timestamp"])).days < 1])
            }

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# MONITOREO DE APLICACI√ìN FLASK
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

class ERCFlaskMonitor:
    """Monitor especializado para la aplicaci√≥n Flask ERC Insight"""
    
    def __init__(self, base_url: str = "http://localhost:5000"):
        self.base_url = base_url
        self.endpoints_to_monitor = [
            "/api/health",
            "/api/generate_report",
            "/api/parse_document", 
            "/patient/api/tfg"
        ]
        self.monitoring_log = []
        self.lock = threading.Lock()
    
    @police_monitor("flask_health_check")
    def check_application_health(self) -> Dict[str, Any]:
        """Chequea salud general de la aplicaci√≥n Flask"""
        health_result = {
            "timestamp": datetime.now().isoformat(),
            "overall_status": "pending",
            "endpoints": [],
            "response_times": {},
            "errors": [],
            "alerts": []
        }
        
        try:
            # üîç CHEQUEAR ENDPOINTS CR√çTICOS
            all_healthy = True
            total_response_time = 0
            
            for endpoint in self.endpoints_to_monitor:
                endpoint_result = self._check_endpoint(endpoint)
                health_result["endpoints"].append(endpoint_result)
                
                if endpoint_result["status"] != "healthy":
                    all_healthy = False
                    health_result["errors"].append(f"Endpoint {endpoint} unhealthy: {endpoint_result.get('error', 'Unknown')}")
                
                if "response_time" in endpoint_result:
                    health_result["response_times"][endpoint] = endpoint_result["response_time"]
                    total_response_time += endpoint_result["response_time"]
            
            # üìä CALCULAR M√âTRICAS GENERALES
            avg_response_time = total_response_time / len(self.endpoints_to_monitor) if self.endpoints_to_monitor else 0
            health_result["average_response_time"] = round(avg_response_time, 3)
            
            # üö® EVALUAR ESTADO GENERAL
            if not all_healthy:
                health_result["overall_status"] = "unhealthy"
                health_result["alerts"].append("CR√çTICO: Uno o m√°s endpoints no responden correctamente")
            elif avg_response_time > 5.0:
                health_result["overall_status"] = "degraded"
                health_result["alerts"].append(f"ADVERTENCIA: Tiempo de respuesta elevado ({avg_response_time:.2f}s)")
            else:
                health_result["overall_status"] = "healthy"
            
            self._log_monitoring_event(health_result)
            return health_result
            
        except Exception as e:
            health_result["overall_status"] = "error"
            health_result["errors"].append(f"Error en health check: {str(e)}")
            POLICE_LOGGER.error(f"üö® Error en health check: {str(e)}")
            return health_result
    
    def _check_endpoint(self, endpoint: str) -> Dict[str, Any]:
        """Chequea un endpoint espec√≠fico"""
        result = {
            "endpoint": endpoint,
            "status": "pending",
            "response_time": None,
            "status_code": None,
            "error": None
        }
        
        try:
            start_time = time.time()
            url = f"{self.base_url}{endpoint}"
            
            response = requests.get(url, timeout=10)
            response_time = time.time() - start_time
            
            result["response_time"] = round(response_time, 3)
            result["status_code"] = response.status_code
            
            if response.status_code == 200:
                result["status"] = "healthy"
            elif response.status_code in [404, 405]:
                result["status"] = "not_found"
                result["error"] = f"HTTP {response.status_code}"
            else:
                result["status"] = "unhealthy"
                result["error"] = f"HTTP {response.status_code}"
                
        except requests.exceptions.ConnectionError:
            result["status"] = "unreachable"
            result["error"] = "Connection refused - Application not running?"
        except requests.exceptions.Timeout:
            result["status"] = "timeout"
            result["error"] = "Request timeout (>10s)"
        except Exception as e:
            result["status"] = "error"
            result["error"] = str(e)
        
        return result
    
    @police_monitor("medical_endpoint_validation")
    def validate_medical_endpoints(self) -> Dict[str, Any]:
        """Valida endpoints m√©dicos espec√≠ficos con datos de prueba"""
        validation_result = {
            "timestamp": datetime.now().isoformat(),
            "endpoints_validated": [],
            "status": "pending",
            "errors": [],
            "alerts": []
        }
        
        # üß™ DATOS DE PRUEBA PARA ENDPOINTS M√âDICOS
        test_cases = {
            "/patient/api/tfg": {
                "method": "POST",
                "data": {
                    "edad": 65,
                    "peso": 70,
                    "creatinina": 1.2,
                    "sexo": "m"
                },
                "expected_fields": ["tfg", "etapa_erc"]
            }
        }
        
        try:
            for endpoint, test_config in test_cases.items():
                endpoint_result = self._validate_medical_endpoint(endpoint, test_config)
                validation_result["endpoints_validated"].append(endpoint_result)
                
                if endpoint_result["status"] != "success":
                    validation_result["errors"].append(f"{endpoint}: {endpoint_result.get('error', 'Unknown error')}")
            
            # üìä EVALUAR RESULTADO GENERAL
            if validation_result["errors"]:
                validation_result["status"] = "failed"
                validation_result["alerts"].append("CR√çTICO: Validaci√≥n de endpoints m√©dicos fall√≥")
            else:
                validation_result["status"] = "success"
            
            self._log_monitoring_event(validation_result)
            return validation_result
            
        except Exception as e:
            validation_result["status"] = "error"
            validation_result["errors"].append(f"Error en validaci√≥n: {str(e)}")
            return validation_result
    
    def _validate_medical_endpoint(self, endpoint: str, test_config: Dict[str, Any]) -> Dict[str, Any]:
        """Valida un endpoint m√©dico espec√≠fico"""
        result = {
            "endpoint": endpoint,
            "status": "pending",
            "response_data": None,
            "validation_errors": [],
            "error": None
        }
        
        try:
            url = f"{self.base_url}{endpoint}"
            
            if test_config["method"] == "POST":
                response = requests.post(url, json=test_config["data"], timeout=10)
            else:
                response = requests.get(url, timeout=10)
            
            if response.status_code != 200:
                result["status"] = "failed"
                result["error"] = f"HTTP {response.status_code}: {response.text}"
                return result
            
            # üß™ VALIDAR ESTRUCTURA DE RESPUESTA
            try:
                response_data = response.json()
                result["response_data"] = response_data
                
                # Validar campos esperados
                if "expected_fields" in test_config:
                    for field in test_config["expected_fields"]:
                        if field not in response_data:
                            result["validation_errors"].append(f"Campo faltante: {field}")
                
                # Validaciones espec√≠ficas para TFG
                if endpoint == "/patient/api/tfg":
                    if "tfg" in response_data:
                        tfg = response_data["tfg"]
                        if not isinstance(tfg, (int, float)) or tfg < 0 or tfg > 200:
                            result["validation_errors"].append(f"TFG inv√°lido: {tfg}")
                    
                    if "etapa_erc" in response_data:
                        etapa = response_data["etapa_erc"]
                        if etapa not in ["g1", "g2", "g3a", "g3b", "g4", "g5"]:
                            result["validation_errors"].append(f"Etapa ERC inv√°lida: {etapa}")
                
                if result["validation_errors"]:
                    result["status"] = "validation_failed"
                else:
                    result["status"] = "success"
                    
            except json.JSONDecodeError:
                result["status"] = "failed"
                result["error"] = "Respuesta no es JSON v√°lido"
                
        except Exception as e:
            result["status"] = "error"
            result["error"] = str(e)
        
        return result
    
    def _log_monitoring_event(self, event_data: Dict[str, Any]):
        """Registra evento de monitoreo"""
        with self.lock:
            self.monitoring_log.append(event_data)
            
            # Mantener solo los √∫ltimos 500 eventos
            if len(self.monitoring_log) > 500:
                self.monitoring_log = self.monitoring_log[-500:]

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# EXTENSI√ìN DE LA CLASE WATCHDOG PRINCIPAL
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

def extend_watchdog_with_medical_monitoring():
    """Extiende la clase ERCPoliceWatchdog con funciones m√©dicas"""
    
    if not PARTE1_AVAILABLE:
        POLICE_LOGGER.warning("PARTE 1 no disponible - creando extensi√≥n b√°sica")
        return None
    
    # A√±adir m√©todos m√©dicos a la clase principal
    ERCPoliceWatchdog.medical_validator = None
    ERCPoliceWatchdog.flask_monitor = None
    
    def init_medical_monitoring(self):
        """Inicializa monitoreo m√©dico"""
        self.medical_validator = ERCMedicalValidator(self.config.medical_rules)
        self.flask_monitor = ERCFlaskMonitor(self.config.app_url)
        POLICE_LOGGER.info("üè• Medical monitoring initialized")
    
    def run_medical_validation_cycle(self):
        """Ejecuta ciclo completo de validaciones m√©dicas"""
        try:
            # Test de validaci√≥n TFG
            tfg_result = self.medical_validator.validate_tfg_cockcroft_gault(65, 70, 1.2, "m")
            
            # Test de endpoints m√©dicos
            endpoints_result = self.flask_monitor.validate_medical_endpoints()
            
            # Health check general
            health_result = self.flask_monitor.check_application_health()
            
            return {
                "tfg_validation": tfg_result,
                "endpoints_validation": endpoints_result,
                "health_check": health_result,
                "timestamp": datetime.now().isoformat()
            }
            
        except Exception as e:
            POLICE_LOGGER.error(f"üö® Error en ciclo de validaci√≥n m√©dica: {str(e)}")
            return {"error": str(e), "timestamp": datetime.now().isoformat()}
    
    # A√±adir m√©todos a la clase
    ERCPoliceWatchdog.init_medical_monitoring = init_medical_monitoring
    ERCPoliceWatchdog.run_medical_validation_cycle = run_medical_validation_cycle
    
    return ERCPoliceWatchdog

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# PUNTO DE ENTRADA Y DEMO
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

if __name__ == "__main__":
    print("üè• ERC Police Watchdog - Parte 2 (Chequeo y Enforcement M√©dico)")
    print("=" * 70)
    
    # Inicializar validador m√©dico
    print("\nüìã Inicializando validador m√©dico...")
    validator = ERCMedicalValidator()
    
    # Test de validaciones m√©dicas
    print("\nüß™ Ejecutando tests de validaciones m√©dicas...")
    
    # Test 1: C√°lculo TFG
    print("\n1Ô∏è‚É£ Test TFG Cockcroft-Gault:")
    tfg_result = validator.validate_tfg_cockcroft_gault(65, 70, 1.2, "m")
    print(f"   TFG: {tfg_result['tfg']} ml/min/1.73m¬≤ - Estadio: {tfg_result['estadio']}")
    print(f"   Estado: {tfg_result['status']}")
    if tfg_result['alerts']:
        print(f"   Alertas: {tfg_result['alerts']}")
    
    # Test 2: Riesgo cardiovascular  
    print("\n2Ô∏è‚É£ Test Riesgo Cardiovascular:")
    patient_test = {
        "edad": 70,
        "sexo": "m", 
        "tfg": 45,
        "dm2": True,
        "hta": True,
        "tabaquismo": False
    }
    cv_result = validator.validate_cardiovascular_risk(patient_test)
    print(f"   Riesgo: {cv_result['risk_level']} (Score: {cv_result['score']})")
    print(f"   Factores: {len(cv_result['factors'])}")
    
    # Test 3: Metas terap√©uticas
    print("\n3Ô∏è‚É£ Test Metas Terap√©uticas:")
    lab_test = {
        "presion_sistolica": 145,
        "presion_diastolica": 85,
        "glicemia": 140,
        "rac": 45
    }
    goals_result = validator.validate_therapeutic_goals(patient_test, lab_test)
    print(f"   Cumplimiento: {goals_result['compliance_score']}%")
    print(f"   Metas logradas: {len(goals_result['goals_met'])}")
    print(f"   Metas pendientes: {len(goals_result['goals_not_met'])}")
    
    # Test 4: Seguridad de medicamentos
    print("\n4Ô∏è‚É£ Test Seguridad Medicamentos:")
    medications_test = ["Enalapril", "Metformina", "Empagliflozina"]
    med_result = validator.validate_medication_safety(patient_test, medications_test)
    print(f"   Medicamentos seguros: {len(med_result['safe_medications'])}")
    print(f"   Contraindicaciones: {len(med_result['contraindicated_medications'])}")
    print(f"   Ajustes requeridos: {len(med_result['dose_adjustments'])}")
    
    # Resumen de validaciones
    print("\nüìä Resumen de Validaciones:")
    summary = validator.get_validation_summary()
    print(f"   Total realizadas: {summary['total_validations']}")
    print(f"   Exitosas: {summary['successful']}")
    print(f"   Tasa de √©xito: {summary['success_rate']}%")
    
    # Test de monitor Flask (si est√° disponible)
    print("\nüåê Test Monitor Flask:")
    monitor = ERCFlaskMonitor()
    health = monitor.check_application_health()
    print(f"   Estado general: {health['overall_status']}")
    print(f"   Endpoints chequeados: {len(health['endpoints'])}")
    if health['average_response_time']:
        print(f"   Tiempo respuesta promedio: {health['average_response_time']}s")
    
    print("\nüéØ PARTE 2 COMPLETADA - Lista para PARTE 3")
    print("   ‚úÖ Validaciones m√©dicas implementadas")
    print("   ‚úÖ Monitoreo de Flask funcional") 
    print("   ‚úÖ Sistema de alertas m√©dicas activo")
    print("   ‚úÖ Enforcement de reglas cl√≠nicas operativo")

"""
üìã PARTE 2 COMPLETADA - INSTRUCCIONES PARA ENSAMBLAJE:

‚úÖ INCLUYE:
- ERCMedicalValidator: Validaciones m√©dicas espec√≠ficas de ERC
- ERCFlaskMonitor: Monitoreo especializado de aplicaci√≥n Flask
- Validaci√≥n TFG con f√≥rmula Cockcroft-Gault y enforcement estricto
- Evaluaci√≥n de riesgo cardiovascular con scoring autom√°tico
- Validaci√≥n de metas terap√©uticas por perfil de paciente
- Chequeo de seguridad de medicamentos con contraindicaciones
- Monitoreo de endpoints cr√≠ticos de la aplicaci√≥n
- Sistema de logging de validaciones m√©dicas
- Tests de endpoints m√©dicos con datos de prueba

üîó CONECTA CON PARTE 1:
- Usa decoradores @medical_validation y @police_monitor
- Utiliza POLICE_LOGGER para logging centralizado
- Integra con ERCPoliceConfig para configuraci√≥n
- Extiende clase ERCPoliceWatchdog con funciones m√©dicas

üîó PREPARA PARA PARTE 3:
- Genera eventos detallados para sistema de alertas
- Proporciona m√©tricas para an√°lisis de rendimiento
- Crea logs estructurados para debugging
- Identifica situaciones cr√≠ticas que requieren alertas inmediatas

üè• REGLAS M√âDICAS IMPLEMENTADAS:
- C√°lculo y validaci√≥n TFG seg√∫n estadios KDIGO
- Clasificaci√≥n de riesgo cardiovascular multi-factorial
- Metas terap√©uticas diferenciadas por perfil (ERC+DM, solo ERC)
- Contraindicaciones farmacol√≥gicas por funci√≥n renal
- Alertas m√©dicas cr√≠ticas autom√°ticas
- Cumplimiento de gu√≠as cl√≠nicas internacionales

‚ö° LISTO PARA PARTE 3: Manejo de errores, alertas y sistema de testing
"""
